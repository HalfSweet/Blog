import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as o,b as s,d as t,e as a,o as l,r}from"./app-BvW9zp2N.js";const c="/assets/2023-05-06-15-04-58-DpMHk8Mb.png",u="/assets/2023-05-06-15-21-02-DpbFT8xU.png",d="/assets/2023-05-06-15-29-11-DOwiQ4YX.png",k="/assets/2023-05-06-15-29-39-DvTCV4f2.png",m="/assets/2023-05-06-15-39-02-CWudQtzv.png",T={},g={href:"https://github.com/Air-duino/Air001-SEGGER-RTT-Keil",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack",target:"_blank",rel:"noopener noreferrer"},R={href:"https://github.com/XIVN1987/RTTView",target:"_blank",rel:"noopener noreferrer"};function E(S,n){const e=r("ExternalLinkIcon");return l(),p("div",null,[n[10]||(n[10]=o('<p>在日常的开发中，我们免不了使用各种各样的日志打印方式，使用调试器固然好用，但是无法直接打印局部变量以及会打断整个运行状态。并且对于众多<code>Arduino</code>的用户来说，直接打印日志显然是更直观的做法。但是直接使用串口打印的话需要一定的资源，并且速度会稍慢，并且可能会占用一个串口，对于资源就不多的MCU，我们有没有更方便的方法呢？</p><h2 id="调试方式" tabindex="-1"><a class="header-anchor" href="#调试方式"><span>调试方式</span></a></h2><h3 id="使用swo" tabindex="-1"><a class="header-anchor" href="#使用swo"><span>使用SWO</span></a></h3><p>对于这个问题，众多厂商也有着相同的需求，于是Arm公司便提出了一种叫做<code>Serial Wire Output</code>的协议，我们将其简称为<code>SWO</code>。简单来说，它是一种用于调试的接口协议。SWO是在ARM Cortex-M微控制器上实现的，它允许调试器通过单个引脚输出数据，而不需要占用其他引脚。使用SWO接口，可以在运行时输出调试信息，例如程序状态、变量值、函数返回值等，从而帮助开发人员进行调试。</p><p>在<code>STM32</code>微处理器的编程中，我们只需要在<code>STM32CubeMX</code>软件中打开异步跟踪模式即可使用SWO进行输出调试，相比与串口的打印，使用SWO明显效率更高，占用的引脚更少。 <img src="'+c+'" alt=""> 但是遗憾的是，采用SWO的日志输出依然会占用一个IO，并且只能和SWD/JTAG等调试口联用。那么我们有没有一种方法，可以做到只使用调试接口就可以输出日志，并且拥有相似甚至更高的效率呢？</p><h3 id="segger-rtt" tabindex="-1"><a class="header-anchor" href="#segger-rtt"><span>SEGGER-RTT</span></a></h3><p>在此基础上，伟大的<code>SEGGER Microcontroller</code>公司便推出了一种新的日志打印方式，称之为<code>Real-Time Transfer</code>，也就是简称的<code>RTT</code>。什么？你没听过这个公司？那你总用过<code>J-Link</code>吧，是的，它们出自于一家公司。</p><p>SEGGER-RTT 的原理是通过在目标设备上的专用软件库，将实时数据通过 JTAG/SWD 接口传输到 Host 端。这个过程中不需要额外的硬件支持，只需要使用 SEGGER 的调试器和它的支持的 IDE（如SEGGER&#39;s Embedded Studio或其他兼容IDE）。SEGGER-RTT 通过利用调试器的访问权限，从调试目标设备的内部缓冲区中读取数据，并将这些数据发送到 Host 端进行处理和显示。同时也可以在 Host 端向目标设备发送数据，以便执行一些控制操作或者更改程序的状态。由于 SEGGER-RTT 可以非常快速地传输大量数据，因此它通常被用于实时性要求较高的应用程序中。</p><h2 id="移植segger-rtt" tabindex="-1"><a class="header-anchor" href="#移植segger-rtt"><span>移植SEGGER-RTT</span></a></h2><p>我们来尝试在Air001单片机上移植SEGGER-RTT。移植好的工程开源链接：</p>',10)),s("p",null,[s("a",g,[n[0]||(n[0]=t("https://github.com/Air-duino/Air001-SEGGER-RTT-Keil")),a(e)])]),n[11]||(n[11]=s("h3",{id:"_0x01-安装j-link",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_0x01-安装j-link"},[s("span",null,"0x01 安装J-Link")])],-1)),s("p",null,[n[2]||(n[2]=t("第一步，我们先下载一个")),s("a",h,[n[1]||(n[1]=t("Jlink全家桶")),a(e)]),n[3]||(n[3]=t("，然后安装。 然后在如图所示的安装目录下，我们应该可以看到这样的一个压缩文件： ")),n[4]||(n[4]=s("img",{src:u,alt:""},null,-1)),n[5]||(n[5]=t(" 解压它，备用。"))]),n[12]||(n[12]=o('<h3 id="_0x02-加入keil工程" tabindex="-1"><a class="header-anchor" href="#_0x02-加入keil工程"><span>0x02 加入Keil工程</span></a></h3><p>我们将<code>xxx/JLink\\Samples\\RTT\\SEGGER_RTT_V788a\\</code>下的<code>RTT</code>和<code>Config</code>文件夹复制到我们的工程目录下，并加入到Keil工程中，别忘了添加头文件。 <img src="'+d+'" alt=""><img src="'+k+`" alt=""></p><h3 id="_0x03-初始化并调用" tabindex="-1"><a class="header-anchor" href="#_0x03-初始化并调用"><span>0x03 初始化并调用</span></a></h3><p>在<code>main.c</code>文件中include头文件，并初始化。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HS_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HS_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">SEGGER_RTT_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">SEGGER_RTT_printf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello world ! \\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">SEGGER_RTT_printf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;This is the %dst print \\n&quot;</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">HAL_Delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5)),s("p",null,[n[7]||(n[7]=t("因为我们使用的是DAPLink，Jlink的软件无法识别，因此我们使用了一个第三方的软件： ")),s("a",R,[n[6]||(n[6]=t("https://github.com/XIVN1987/RTTView")),a(e)]),n[8]||(n[8]=s("img",{src:m,alt:""},null,-1)),n[9]||(n[9]=t(" 打印出了预期的结果。"))]),n[13]||(n[13]=s("h2",{id:"后记",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#后记"},[s("span",null,"后记")])],-1)),n[14]||(n[14]=s("ul",null,[s("li",null,"思考：效率是否能进一步提高呢？")],-1))])}const v=i(T,[["render",E],["__file","index.html.vue"]]),b=JSON.parse(`{"path":"/posts/SEGGER-RTT/","title":"更高效的日志查看方式——使用SEGGER-RTT","lang":"zh-CN","frontmatter":{"title":"更高效的日志查看方式——使用SEGGER-RTT","date":"2023-05-06T14:48:05.000Z","permalink":"/posts/SEGGER-RTT/","category":["单片机"],"tag":["Air001","合宙","日志"],"author":{"name":"HalfSweet","link":"https://github.com/HalfSweet"},"description":"在日常的开发中，我们免不了使用各种各样的日志打印方式，使用调试器固然好用，但是无法直接打印局部变量以及会打断整个运行状态。并且对于众多Arduino的用户来说，直接打印日志显然是更直观的做法。但是直接使用串口打印的话需要一定的资源，并且速度会稍慢，并且可能会占用一个串口，对于资源就不多的MCU，我们有没有更方便的方法呢？ 调试方式 使用SWO 对于这个...","head":[["meta",{"property":"og:url","content":"https://halfsweet.cn/posts/SEGGER-RTT/"}],["meta",{"property":"og:site_name","content":"HalfSweet's Blog"}],["meta",{"property":"og:title","content":"更高效的日志查看方式——使用SEGGER-RTT"}],["meta",{"property":"og:description","content":"在日常的开发中，我们免不了使用各种各样的日志打印方式，使用调试器固然好用，但是无法直接打印局部变量以及会打断整个运行状态。并且对于众多Arduino的用户来说，直接打印日志显然是更直观的做法。但是直接使用串口打印的话需要一定的资源，并且速度会稍慢，并且可能会占用一个串口，对于资源就不多的MCU，我们有没有更方便的方法呢？ 调试方式 使用SWO 对于这个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-23T06:35:02.000Z"}],["meta",{"property":"article:author","content":"HalfSweet"}],["meta",{"property":"article:tag","content":"Air001"}],["meta",{"property":"article:tag","content":"合宙"}],["meta",{"property":"article:tag","content":"日志"}],["meta",{"property":"article:published_time","content":"2023-05-06T14:48:05.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-23T06:35:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"更高效的日志查看方式——使用SEGGER-RTT\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-05-06T14:48:05.000Z\\",\\"dateModified\\":\\"2024-03-23T06:35:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HalfSweet\\",\\"link\\":\\"https://github.com/HalfSweet\\"}]}"]]},"headers":[{"level":2,"title":"调试方式","slug":"调试方式","link":"#调试方式","children":[{"level":3,"title":"使用SWO","slug":"使用swo","link":"#使用swo","children":[]},{"level":3,"title":"SEGGER-RTT","slug":"segger-rtt","link":"#segger-rtt","children":[]}]},{"level":2,"title":"移植SEGGER-RTT","slug":"移植segger-rtt","link":"#移植segger-rtt","children":[{"level":3,"title":"0x01 安装J-Link","slug":"_0x01-安装j-link","link":"#_0x01-安装j-link","children":[]},{"level":3,"title":"0x02 加入Keil工程","slug":"_0x02-加入keil工程","link":"#_0x02-加入keil工程","children":[]},{"level":3,"title":"0x03 初始化并调用","slug":"_0x03-初始化并调用","link":"#_0x03-初始化并调用","children":[]}]},{"level":2,"title":"后记","slug":"后记","link":"#后记","children":[]}],"git":{"createdTime":1692418551000,"updatedTime":1711175702000,"contributors":[{"name":"HalfSweet","email":"halfsweet@halfsweet.cn","commits":2}]},"readingTime":{"minutes":3.44,"words":1033},"filePathRelative":"posts/更高效的日志查看方式——使用SEGGER-RTT.md","localizedDate":"2023年5月6日","excerpt":"<p>在日常的开发中，我们免不了使用各种各样的日志打印方式，使用调试器固然好用，但是无法直接打印局部变量以及会打断整个运行状态。并且对于众多<code>Arduino</code>的用户来说，直接打印日志显然是更直观的做法。但是直接使用串口打印的话需要一定的资源，并且速度会稍慢，并且可能会占用一个串口，对于资源就不多的MCU，我们有没有更方便的方法呢？</p>\\n","autoDesc":true}`);export{v as comp,b as data};
