import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as a,d as n,e as s,a as r,o,r as d}from"./app-BvW9zp2N.js";const c={},p={href:"https://docs.github.com/cn/actions/learn-github-actions/introduction-to-github-actions",target:"_blank",rel:"noopener noreferrer"},u={href:"https://github.com/Air-duino/Air001-CoreMark",target:"_blank",rel:"noopener noreferrer"};function h(m,e){const t=d("ExternalLinkIcon");return o(),l("div",null,[e[4]||(e[4]=a("p",null,"对于传统的嵌入式开发来说，我们一般常用的IDE都是诸如Keil、IAR等。这些IDE在方便了我们的开发的同时，也存在很多问题，例如在之前Keil-MDK5是不能跨平台的，仅限在Windows平台运行，并且它的授权也是一个老大难的问题。这样我们在团队协作的时候往往就会遇到很多问题，无法像是互联网的开发那样有一套完整的CI/CD流程。但是MDK6的更新解决了这个问题，第一它是跨平台的，这样在Windows、Linux以及MacOS上都能运行；并且也支持了很多命令行的操作，避免了繁琐的GUI操作，这样也更有利于自动化脚本的编写。",-1)),e[5]||(e[5]=a("h2",{id:"ci-cd是什么",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#ci-cd是什么"},[a("span",null,"CI/CD是什么")])],-1)),e[6]||(e[6]=a("p",null,"CI/CD是指持续集成（Continuous Integration）和持续交付（Continuous Delivery），是一种软件开发实践，通过使用自动化的软件工具来加快软件开发的流程，这样可以更快的交付高质量的软件。CI/CD的核心是持续集成，即在开发过程中，频繁的将代码集成到主干上，这样可以更快的发现错误，更快的修复错误。而持续交付则是在持续集成的基础上，将集成后的代码部署到生产环境中，这样可以更快的将新功能交付给用户。",-1)),e[7]||(e[7]=a("p",null,"简单来说，就是作为开发者的我们，只需要关注代码的编写，而不需要关注代码的编译、测试、部署等等，这些都可以通过自动化的脚本来完成。如果有多人协作的场景下，最终产物的编译和交付也可以通过自动化的脚本来完成，而不是传统的需要人工来完成。",-1)),a("p",null,[e[1]||(e[1]=n("在本文中，我们采用Github Actions来完成CI/CD的流程。我假设本文的读者已经对Github Actions有一定的了解，如果没有的话也没关系，可以参考")),a("a",p,[e[0]||(e[0]=n("官方文档")),s(t)]),e[2]||(e[2]=n("，并且本文也会对一些关键的地方进行说明。"))]),e[8]||(e[8]=r(`<h2 id="一些前置条件" tabindex="-1"><a class="header-anchor" href="#一些前置条件"><span>一些前置条件</span></a></h2><ol><li>一个基于Keil-MDK的工程，无论你之前是否配置过MDK6</li><li>你的工程需要用AC6的编译器编译通过</li><li>一个Github账号</li><li>一定的学习能力</li></ol><h2 id="编写github-actions脚本" tabindex="-1"><a class="header-anchor" href="#编写github-actions脚本"><span>编写Github Actions脚本</span></a></h2><p>我们假定你的这个工程在Github上已经新建了一个仓库，如果没有需要先新建一个仓库。然后在仓库的根目录下新建一个<code>.github/workflows</code>文件夹，然后在这个文件夹下新建一个<code>release.yml</code>文件，这个文件就是我们的Github Actions脚本。它的名称无所谓，但是后缀必须是<code>.yml</code>，这是YAML文件的后缀。</p><p>我们略去一些基础的Action的操作，直接进入到关键的一些步骤。</p><h3 id="安装-vcpkg" tabindex="-1"><a class="header-anchor" href="#安装-vcpkg"><span>安装 vcpkg</span></a></h3><p>vcpkg是微软开发的一个C/C++的包管理工具，类似于Python的pip、Node.js的npm、Java的maven等等。在MDK6中它被用来作为很重要的包管理器，因此我们需要保证先安装好它。安装非常简单，只需要：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token builtin class-name">.</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">curl</span> https://aka.ms/vcpkg-init.sh -L<span class="token punctuation">)</span>
<span class="token builtin class-name">.</span> ~/.vcpkg/vcpkg-init
<span class="token function">vcpkg</span> x-update-registry arm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">注</p><p><code>vcpkg x-update-registry arm</code>这一行的作用是更新arm的包列表</p></div><h3 id="将mdk5风格的工程转换为mdk6" tabindex="-1"><a class="header-anchor" href="#将mdk5风格的工程转换为mdk6"><span>将MDK5风格的工程转换为MDK6</span></a></h3><p>这里Arm官方为我们提供了一个叫做<code>uv2csolution</code>的小工具，可以很方便地将<code>uvprojx</code>结尾的MDK5工程转换为MDK6，并且可以使用vcpkg直接安装。我们只需要</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">vcpkg</span> use uv2csolution
<span class="token builtin class-name">cd</span> MDK-ARM
uv2csolution CoreMark.uvprojx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们就将仓库下的<code>MDK-ARM/CoreMark.uvprojx</code>转换为了MDK6的工程。</p><h3 id="activate-vcpkg" tabindex="-1"><a class="header-anchor" href="#activate-vcpkg"><span>activate vcpkg</span></a></h3><p>因为MDK6采用了vcpkg作为包管理工具，因此需要一些工具链的依赖，在转换后的工程的<code>vcpkg-configuration.json</code>中我们可以看到一般所需的依赖。因此我们首先需要运行</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">vcpkg</span> activate
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>去激活环境并自动安装这些所需的依赖。这个过程可能有些漫长，但是我们只需要等待。</p><h3 id="激活armclang社区许可证" tabindex="-1"><a class="header-anchor" href="#激活armclang社区许可证"><span>激活ArmClang社区许可证</span></a></h3><p>相信不少人在MDK5的学习中，都被许可证问题所困扰过，无数人都曾会对着那个会尖叫的注册机发过呆。但是在MDK6中，Arm为我们提供了一个免费社区许可证，我们可以很轻易地激活并使用。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>这是社区许可证，不能使用在任何商业用途中！！！</p><p>如果你需要商业使用，请联系Arm购买商业许可证！！！</p></div><p>我们只需要运行命令：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>armlm activate <span class="token parameter variable">-product</span> KEMDK-COM0 <span class="token parameter variable">-server</span> https://mdk-preview.keil.arm.com
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>即可激活社区许可证。</p><h3 id="开始编译" tabindex="-1"><a class="header-anchor" href="#开始编译"><span>开始编译</span></a></h3><p>万事俱备，我们只需要运行</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>cbuild CoreMark.csolution.yml --update-rte <span class="token parameter variable">--packs</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，<code>CoreMark</code>替换成你的实际工程名，<code>--update-rte</code>表示更新RTE文件，<code>--packs</code>表示自动安装所需的包。</p><p>如果一切顺利的话，我们会发现终端吐出一大堆编译的log，并且会有类似：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Program Size: Code=25188 RO-data=2168 RW-data=216 ZI-data=1736  
info cbuild: build finished successfully!
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的提示，表示编译成功。</p><h3 id="生成hex及bin文件" tabindex="-1"><a class="header-anchor" href="#生成hex及bin文件"><span>生成hex及bin文件</span></a></h3><p>编译完成后，默认生成的是axf，如果希望分发的话我们希望是hex或者bin文件，在这里我们可以使用ArmClang自带的<code>fromelf</code>命令来转换。</p><p>但是在运行之前，我们需要单独开一个ArmClang的环境，因此我们先结束掉之前的vcpkg环境</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">vcpkg</span> deactivate
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后开启一个新的</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">vcpkg</span> use armclang
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样我们就可以直接用<code>fromelf</code>命令来转换了</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>fromelf <span class="token parameter variable">--bin</span> <span class="token parameter variable">--output</span><span class="token operator">=</span><span class="token string">&quot;out/CoreMark/Project/CoreMark.bin&quot;</span> <span class="token string">&quot;out/CoreMark/Project/CoreMark.axf&quot;</span>
fromelf <span class="token parameter variable">--i32</span> <span class="token parameter variable">--output</span><span class="token operator">=</span><span class="token string">&quot;out/CoreMark/Project/CoreMark.hex&quot;</span> <span class="token string">&quot;out/CoreMark/Project/CoreMark.axf&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="release" tabindex="-1"><a class="header-anchor" href="#release"><span>Release</span></a></h2><p>这个时候我们将最终文件上传到release中就好了，这里我用的是<code>ncipollo/release-action</code>这个插件。具体的操作可以看演示仓库。</p><h2 id="faq" tabindex="-1"><a class="header-anchor" href="#faq"><span>FAQ</span></a></h2><p>有问题可以评论区留言，遇到的问题可以更新在FAQ里。</p><h2 id="演示仓库" tabindex="-1"><a class="header-anchor" href="#演示仓库"><span>演示仓库</span></a></h2>`,43)),a("p",null,[a("a",u,[e[3]||(e[3]=n("https://github.com/Air-duino/Air001-CoreMark")),s(t)])])])}const b=i(c,[["render",h],["__file","index.html.vue"]]),k=JSON.parse(`{"path":"/posts/Empedded-CI-CD/","title":"嵌入式中的 CI/CD","lang":"zh-CN","frontmatter":{"title":"嵌入式中的 CI/CD","date":"2024-01-07T12:30:00.000Z","permalink":"/posts/Empedded-CI-CD/","category":["单片机"],"tag":["Air001","合宙","CI/CD"],"author":{"name":"HalfSweet","link":"https://github.com/HalfSweet"},"description":"对于传统的嵌入式开发来说，我们一般常用的IDE都是诸如Keil、IAR等。这些IDE在方便了我们的开发的同时，也存在很多问题，例如在之前Keil-MDK5是不能跨平台的，仅限在Windows平台运行，并且它的授权也是一个老大难的问题。这样我们在团队协作的时候往往就会遇到很多问题，无法像是互联网的开发那样有一套完整的CI/CD流程。但是MDK6的更新解决...","head":[["meta",{"property":"og:url","content":"https://halfsweet.cn/posts/Empedded-CI-CD/"}],["meta",{"property":"og:site_name","content":"HalfSweet's Blog"}],["meta",{"property":"og:title","content":"嵌入式中的 CI/CD"}],["meta",{"property":"og:description","content":"对于传统的嵌入式开发来说，我们一般常用的IDE都是诸如Keil、IAR等。这些IDE在方便了我们的开发的同时，也存在很多问题，例如在之前Keil-MDK5是不能跨平台的，仅限在Windows平台运行，并且它的授权也是一个老大难的问题。这样我们在团队协作的时候往往就会遇到很多问题，无法像是互联网的开发那样有一套完整的CI/CD流程。但是MDK6的更新解决..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-23T06:39:37.000Z"}],["meta",{"property":"article:author","content":"HalfSweet"}],["meta",{"property":"article:tag","content":"Air001"}],["meta",{"property":"article:tag","content":"合宙"}],["meta",{"property":"article:tag","content":"CI/CD"}],["meta",{"property":"article:published_time","content":"2024-01-07T12:30:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-23T06:39:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"嵌入式中的 CI/CD\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-07T12:30:00.000Z\\",\\"dateModified\\":\\"2024-03-23T06:39:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HalfSweet\\",\\"link\\":\\"https://github.com/HalfSweet\\"}]}"]]},"headers":[{"level":2,"title":"CI/CD是什么","slug":"ci-cd是什么","link":"#ci-cd是什么","children":[]},{"level":2,"title":"一些前置条件","slug":"一些前置条件","link":"#一些前置条件","children":[]},{"level":2,"title":"编写Github Actions脚本","slug":"编写github-actions脚本","link":"#编写github-actions脚本","children":[{"level":3,"title":"安装 vcpkg","slug":"安装-vcpkg","link":"#安装-vcpkg","children":[]},{"level":3,"title":"将MDK5风格的工程转换为MDK6","slug":"将mdk5风格的工程转换为mdk6","link":"#将mdk5风格的工程转换为mdk6","children":[]},{"level":3,"title":"activate vcpkg","slug":"activate-vcpkg","link":"#activate-vcpkg","children":[]},{"level":3,"title":"激活ArmClang社区许可证","slug":"激活armclang社区许可证","link":"#激活armclang社区许可证","children":[]},{"level":3,"title":"开始编译","slug":"开始编译","link":"#开始编译","children":[]},{"level":3,"title":"生成hex及bin文件","slug":"生成hex及bin文件","link":"#生成hex及bin文件","children":[]}]},{"level":2,"title":"Release","slug":"release","link":"#release","children":[]},{"level":2,"title":"FAQ","slug":"faq","link":"#faq","children":[]},{"level":2,"title":"演示仓库","slug":"演示仓库","link":"#演示仓库","children":[]}],"git":{"createdTime":1704604649000,"updatedTime":1711175977000,"contributors":[{"name":"HalfSweet","email":"halfsweet@halfsweet.cn","commits":3}]},"readingTime":{"minutes":5.17,"words":1550},"filePathRelative":"posts/嵌入式中的CI-CD.md","localizedDate":"2024年1月7日","excerpt":"<p>对于传统的嵌入式开发来说，我们一般常用的IDE都是诸如Keil、IAR等。这些IDE在方便了我们的开发的同时，也存在很多问题，例如在之前Keil-MDK5是不能跨平台的，仅限在Windows平台运行，并且它的授权也是一个老大难的问题。这样我们在团队协作的时候往往就会遇到很多问题，无法像是互联网的开发那样有一套完整的CI/CD流程。但是MDK6的更新解决了这个问题，第一它是跨平台的，这样在Windows、Linux以及MacOS上都能运行；并且也支持了很多命令行的操作，避免了繁琐的GUI操作，这样也更有利于自动化脚本的编写。</p>\\n","autoDesc":true}`);export{b as comp,k as data};
