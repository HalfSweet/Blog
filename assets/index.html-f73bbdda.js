const e=JSON.parse(`{"key":"v-8197c92e","path":"/posts/Air32-HAL-MCO/","title":"Air32 的 HAL 改造——适配 MCO","lang":"zh-CN","frontmatter":{"title":"Air32 的 HAL 改造——适配 MCO","date":"2023-08-20T23:00:00.000Z","permalink":"/posts/Air32-HAL-MCO/","category":["单片机"],"tag":["Air32","合宙","MCO"],"author":{"name":"HalfSweet","link":"https://github.com/HalfSweet"},"order":8,"description":"在 [上篇文章](./发挥全部实力！Air32 在 HAL 库环境下运行最高主频。md) 中，我们把 HAL 库移植给了 Air32，那现在让我们尝试添加一些 HAL 库特有的功能吧，比如这篇文章中描述的MCO。 关于 MCO 全称为Microcontroller clock output，即微控制器时钟输出，它可以将主时钟输出到某个引脚上，这样我们就可以在不消耗任何资源的情况下得到一些特定的时钟信号。 在 STM32F103 中，MCO 对于 PLL 的输出有两种选择，分别是 PLL/2 和 PLL/3，但是这对于主频高达 256M 的 Air32 来说显然是不够的，因为其 GPIO 输出最大仅 50M。因此 Air32 有了专属的一个寄存器来控制 MCO 的输出，这个寄存器就是RCC_MCO_VAL，其相对 RCC 的偏移量为0x30。","head":[["meta",{"property":"og:url","content":"https://halfsweet.cn/posts/Air32-HAL-MCO/"}],["meta",{"property":"og:site_name","content":"HalfSweet's Blog"}],["meta",{"property":"og:title","content":"Air32 的 HAL 改造——适配 MCO"}],["meta",{"property":"og:description","content":"在 [上篇文章](./发挥全部实力！Air32 在 HAL 库环境下运行最高主频。md) 中，我们把 HAL 库移植给了 Air32，那现在让我们尝试添加一些 HAL 库特有的功能吧，比如这篇文章中描述的MCO。 关于 MCO 全称为Microcontroller clock output，即微控制器时钟输出，它可以将主时钟输出到某个引脚上，这样我们就可以在不消耗任何资源的情况下得到一些特定的时钟信号。 在 STM32F103 中，MCO 对于 PLL 的输出有两种选择，分别是 PLL/2 和 PLL/3，但是这对于主频高达 256M 的 Air32 来说显然是不够的，因为其 GPIO 输出最大仅 50M。因此 Air32 有了专属的一个寄存器来控制 MCO 的输出，这个寄存器就是RCC_MCO_VAL，其相对 RCC 的偏移量为0x30。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-20T15:24:22.000Z"}],["meta",{"property":"article:author","content":"HalfSweet"}],["meta",{"property":"article:tag","content":"Air32"}],["meta",{"property":"article:tag","content":"合宙"}],["meta",{"property":"article:tag","content":"MCO"}],["meta",{"property":"article:published_time","content":"2023-08-20T23:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-20T15:24:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Air32 的 HAL 改造——适配 MCO\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-20T23:00:00.000Z\\",\\"dateModified\\":\\"2023-08-20T15:24:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HalfSweet\\",\\"link\\":\\"https://github.com/HalfSweet\\"}]}"]]},"headers":[{"level":2,"title":"关于","slug":"关于","link":"#关于","children":[]},{"level":2,"title":"添加寄存器地址","slug":"添加寄存器地址","link":"#添加寄存器地址","children":[]},{"level":2,"title":"添加 RCC_MCO_VAL 的定义","slug":"添加-rcc-mco-val-的定义","link":"#添加-rcc-mco-val-的定义","children":[]},{"level":2,"title":"修改 IS_RCC_MCO1SOURCE 宏定义","slug":"修改-is-rcc-mco1source-宏定义","link":"#修改-is-rcc-mco1source-宏定义","children":[]},{"level":2,"title":"添加 MCO1 Clock Source 相关宏定义","slug":"添加-mco1-clock-source-相关宏定义","link":"#添加-mco1-clock-source-相关宏定义","children":[]},{"level":2,"title":"修改 HAL_RCC_MCOConfig 函数","slug":"修改-hal-rcc-mcoconfig-函数","link":"#修改-hal-rcc-mcoconfig-函数","children":[]},{"level":2,"title":"附录","slug":"附录","link":"#附录","children":[]}],"git":{"createdTime":1692545062000,"updatedTime":1692545062000,"contributors":[{"name":"HalfSweet","email":"halfsweet@halfsweet.cn","commits":1}]},"readingTime":{"minutes":3.04,"words":911},"filePathRelative":"posts/Air32的HAL改造——适配MCO.md","localizedDate":"2023年8月20日","excerpt":"<p>在 [上篇文章](./发挥全部实力！Air32 在 HAL 库环境下运行最高主频。md) 中，我们把 HAL 库移植给了 Air32，那现在让我们尝试添加一些 HAL 库特有的功能吧，比如这篇文章中描述的<code>MCO</code>。</p>\\n<!--more-->\\n<h2> 关于</h2>\\n<p>MCO 全称为<code>Microcontroller clock output</code>，即微控制器时钟输出，它可以将主时钟输出到某个引脚上，这样我们就可以在不消耗任何资源的情况下得到一些特定的时钟信号。</p>\\n<p>在 STM32F103 中，MCO 对于 PLL 的输出有两种选择，分别是 PLL/2 和 PLL/3，但是这对于主频高达 256M 的 Air32 来说显然是不够的，因为其 GPIO 输出最大仅 50M。因此 Air32 有了专属的一个寄存器来控制 MCO 的输出，这个寄存器就是<code>RCC_MCO_VAL</code>，其相对 RCC 的偏移量为<code>0x30</code>。</p>","autoDesc":true}`);export{e as data};
